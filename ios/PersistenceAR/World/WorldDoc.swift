//
//  WorldDoc.swift
//  WorldAsSupport
//
//  Created by Paul on 10/27/19.
//  Copyright Â© 2019 UPF. All rights reserved.
//

import UIKit
import ARKit

class WorldDoc: NSObject {
    enum Keys: String {
        case dataFile = "Data.plist"
        case thumbImageFile = "thumbImage.png"
    }
    
    private var _data: WorldData?
    private var _docPath: URL?
    
    private var _thumbImage: UIImage?
    var thumbImage: UIImage? {
        get {
            if _thumbImage != nil { return _thumbImage }
        
            let thumbImageURL = docPath.appendingPathComponent(Keys.thumbImageFile.rawValue)
            guard let imageData = try? Data(contentsOf: thumbImageURL) else { return nil }
            _thumbImage = UIImage(data: imageData)
            return _thumbImage
        }
        set {
            _thumbImage = newValue
        }
    }
    
    var data: WorldData? {
        get {
            // return the value if already loaded
            if _data != nil { return _data }
          
            // read the saved file as 'Data'
            let dataURL = docPath.appendingPathComponent(Keys.dataFile.rawValue)
            print("WorldDoc loading data from: \(dataURL)")
            guard let codedData = try? Data(contentsOf: dataURL) else { return nil }
    
            // unarchive the object from the Data object
            _data = try! NSKeyedUnarchiver.unarchiveTopLevelObjectWithData(codedData) as? WorldData

            return _data
        }
        set {
            _data = newValue
        }
    }
    
    var docPath: URL {
        get {
            // 1) return the value if already set
            if _docPath != nil { return _docPath! }
            
            // 2) get next autogenerated path from WorldDatabase
            _docPath = WorldDatabase.nextWorldDocPath()
            
            // 3) create document directory
            createDocumentDirectory(_docPath!)
            
            return _docPath!
        }
        set {
            _docPath = newValue
        }
    }
    
    var codedData: Data {
        get {
            return try! NSKeyedArchiver.archivedData(withRootObject: data!, requiringSecureCoding: true)
        }
    }
    
    func serializeMap(_ worldMap: ARWorldMap) -> Data {
        return try! NSKeyedArchiver.archivedData(withRootObject: worldMap, requiringSecureCoding: true)
    }
    
    init(docPath: URL) {
      super.init()
      self.docPath = docPath
    }
    
    init(name: String) {
        super.init()
        
        // Set the document directory, creating it if necessary
        let path = WorldDatabase.makeWorldDocPath(from: name)
        createDocumentDirectory(path)
        self.docPath = path
        print("WorldDoc using path: \(path)")
        
        // If WorldData has not been previously saved, create it and set the "name" property
        // NOTE: This will trigger a load if the document exists
        if self.data == nil {
            self.data = WorldData(name: name)
        }
    }
    
    func createDocumentDirectory(_ path: URL) {
        do {
            try FileManager.default.createDirectory(at: path, withIntermediateDirectories: true, attributes: nil)
        } catch {
            print("Couldn't create document directory: " + error.localizedDescription)
        }
    }
    
    // MARK: CRUD methods
    
    func saveData() {
        // Build the path of the file to write
        let dataURL = docPath.appendingPathComponent(Keys.dataFile.rawValue)
        print("WorldDoc saving data to: \(dataURL)")
      
       // Write the encoded data to the file.
        do {
            try codedData.write(to: dataURL)
        } catch {
            print("Couldn't write to save file: " + error.localizedDescription)
        }
    }
    
    func saveImages() {
        // 1) Make sure that there are images stored
        if _thumbImage == nil { return }
      
        // 2) Build the paths for each file
        let thumbImageURL = docPath.appendingPathComponent(Keys.thumbImageFile.rawValue)
      
        // 3) Convert the images to Data objects with a PNG representation
        let thumbImageData = _thumbImage!.pngData()
      
        // 4) Write the PNG data to disk
        try! thumbImageData!.write(to: thumbImageURL)
    }
    
    func deleteDoc() {
        if let docPath = _docPath {
            do {
                try FileManager.default.removeItem(at: docPath)
            } catch {
                print("Error deleting data directory: " + error.localizedDescription)
            }
        }
    }
    
    // MARK: - API Upload Actions
    
    func upload(onComplete complete: @escaping (_ : ApiResponse) -> Void) {
        uploadDoc() { (result) in
            if (result.error != nil) {
                complete(result)
                return
            }
            self.uploadMap() { (result) in
                if (result.error != nil) {
                    complete(result)
                    return
                }
                self.uploadWorld(onComplete: complete)
            }
        }
    }
    
    // adds or updates the World on the cloud
    // sets the `currentVersion` field to the local versionId
    func uploadWorld(onComplete complete: @escaping (_ : ApiResponse) -> Void) {
        // build the request
        let request = ApiClient.makeApiRequest(path: "worlds", verb: "POST")
        
        // build the data
        let worldJson = ApiWorld(_id: self.data!.worldId, currentVersion: self.data!.versionId!, name: self.data!.name)
        guard let bodyData = try? ApiClient.encoder.encode(worldJson) else {
            fatalError("Cannot encode World")
        }
        
        // upload the request
        ApiClient.uploadTask(request: request, data: bodyData, complete: complete)
    }
    
    // adds or updates the WorldDoc on the cloud
    func uploadDoc(onComplete complete: @escaping (_ : ApiResponse) -> Void) {
        // build the request
        let request = ApiClient.makeApiRequest(path: "world-docs", verb: "POST")
        
        // build the data
        let worldDocJson = ApiWorldDoc(_id: self.data!.versionId!, lastModified: self.data!.lastModified!)
        guard let bodyData = try? ApiClient.encoder.encode(worldDocJson) else {
            fatalError("Cannot encode WorldDoc")
        }
        
        // upload the request
        ApiClient.uploadTask(request: request, data: bodyData, complete: complete)
    }
    
    func uploadMap(onComplete complete: @escaping (_ : ApiResponse) -> Void) {
        guard let versionId = self.data!.versionId else {
            fatalError("versionId not set")
        }
        
        // build the request
        let request = ApiClient.makeApiRequest(
            path: "world-docs/\(versionId)/world-map",
            verb: "POST",
            contentType: "binary/octet-stream"
        )
        
        // upload the map
        ApiClient.uploadTask(request: request, data: codedData, complete: complete)
    }
    
    // MARK: - API Download Actions
    
    func downloadDoc(onComplete complete: @escaping (_ : ApiResponse) -> Void) {
        guard let data = data else {
            fatalError("data not initialized")
        }
        let request = ApiClient.makeApiRequest(path: "world-docs/\(data.versionId!)", verb: "GET")
        ApiClient.dataTask(request: request) { (apiResponse) in
            if let error = apiResponse.error {
                // error
                print("downloadDoc: error", error)
                complete(apiResponse)
                return
            }
            guard let worldDoc = apiResponse.worldDoc else {
                fatalError("response missing worldDoc")
            }
            data.lastModified = worldDoc.lastModified
            data.needsUpdate = false
            complete(apiResponse)
        }
    }
    
    func downloadWorldData(onComplete complete: @escaping (_ : Error?) -> Void) {
        guard let data = data else {
            fatalError("data not initialized")
        }
        let request = ApiClient.makeApiRequest(path: "world-docs/\(data.versionId!)/world-map", verb: "GET")
        ApiClient.downloadTask(request: request) { (url, error) in
            if let error = error {
                // error
                print("downloadWorldData: error", error)
                complete(error)
                return
            }
            guard let dataURL = url else {
                fatalError("response missing temp file URL")
            }
            
            // read the data from the temp file
            print("WorldDoc loading data from: \(dataURL)")
            guard let codedData = try? Data(contentsOf: dataURL) else {
                fatalError("cannot load data from \(dataURL)")
            }
            
            // unarchive the object from the Data object
            self.data = try! NSKeyedUnarchiver.unarchiveTopLevelObjectWithData(codedData) as? WorldData

            data.needsUpdate = false
            
            // save the new data to the permanent file location
            self.saveData()
            
            complete(nil)
        }
    }
}
