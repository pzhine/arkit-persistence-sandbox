//
//  WorldDoc.swift
//  WorldAsSupport
//
//  Created by Paul on 10/27/19.
//  Copyright Â© 2019 UPF. All rights reserved.
//

import UIKit
import ARKit

class WorldDoc: NSObject {
    enum Keys: String {
        case dataFile = "Data.plist"
        case thumbImageFile = "thumbImage.png"
    }
    
    private var _data: WorldData?
    private var _docPath: URL?
    
    private var _thumbImage: UIImage?
    var thumbImage: UIImage? {
        get {
            if _thumbImage != nil { return _thumbImage }
        
            let thumbImageURL = docPath.appendingPathComponent(Keys.thumbImageFile.rawValue)
            guard let imageData = try? Data(contentsOf: thumbImageURL) else { return nil }
            _thumbImage = UIImage(data: imageData)
            return _thumbImage
        }
        set {
            _thumbImage = newValue
        }
    }
    
    var data: WorldData? {
        get {
            // 1) return the value if already loaded
            if _data != nil { return _data }
          
            // 2) read the saved file as 'Data'
            let dataURL = docPath.appendingPathComponent(Keys.dataFile.rawValue)
            print("WorldDoc loading data from: \(dataURL)")
            guard let codedData = try? Data(contentsOf: dataURL) else { return nil }
    
            // 3) unarchive the object from the Data object
            _data = try! NSKeyedUnarchiver.unarchiveTopLevelObjectWithData(codedData) as? WorldData

            return _data
        }
        set {
            _data = newValue
        }
    }
    
    var docPath: URL {
        get {
            // 1) return the value if already set
            if _docPath != nil { return _docPath! }
            
            // 2) get next autogenerated path from WorldDatabase
            _docPath = WorldDatabase.nextWorldDocPath()
            
            // 3) create document directory
            createDocumentDirectory(_docPath!)
            
            return _docPath!
        }
        set {
            _docPath = newValue
        }
    }
    
    var codedData: Data {
        get {
            return try! NSKeyedArchiver.archivedData(withRootObject: data!, requiringSecureCoding: true)
        }
    }
    
    init(docPath: URL) {
      super.init()
      self.docPath = docPath
    }
    
    init(name: String) {
        super.init()
        
        // Set the document directory, creating it if necessary
        let path = WorldDatabase.makeWorldDocPath(from: name)
        createDocumentDirectory(path)
        self.docPath = path
        print("WorldDoc using path: \(path)")
        
        // If WorldData has not been previously saved, create it and set the "name" property
        // NOTE: This will trigger a load if the document exists
        if self.data == nil {
            self.data = WorldData(name: name)
        }
    }
    
    func createDocumentDirectory(_ path: URL) {
        do {
            try FileManager.default.createDirectory(at: path, withIntermediateDirectories: true, attributes: nil)
        } catch {
            print("Couldn't create document directory: " + error.localizedDescription)
        }
    }
    
    // MARK: CRUD methods
    
    func saveData() {
        // Build the path of the file to write
        let dataURL = docPath.appendingPathComponent(Keys.dataFile.rawValue)
        print("WorldDoc saving data to: \(dataURL)")
      
       // Write the encoded data to the file.
        do {
            try codedData.write(to: dataURL)
        } catch {
            print("Couldn't write to save file: " + error.localizedDescription)
        }
    }
    
    func saveImages() {
        // 1) Make sure that there are images stored
        if _thumbImage == nil { return }
      
        // 2) Build the paths for each file
        let thumbImageURL = docPath.appendingPathComponent(Keys.thumbImageFile.rawValue)
      
        // 3) Convert the images to Data objects with a PNG representation
        let thumbImageData = _thumbImage!.pngData()
      
        // 4) Write the PNG data to disk
        try! thumbImageData!.write(to: thumbImageURL)
    }
    
    func deleteDoc() {
        if let docPath = _docPath {
            do {
                try FileManager.default.removeItem(at: docPath)
            } catch {
                print("Error deleting data directory: " + error.localizedDescription)
            }
        }
    }
    
    // MARK: - API Transactions
    
    func upload(onComplete complete: @escaping (_ : ApiResponse) -> Void) {
        uploadDoc() { (result) in
            if (result.error != nil) {
                complete(result)
                return
            }
            self.uploadMap() { (result) in
                if (result.error != nil) {
                    complete(result)
                    return
                }
                self.uploadWorld(onComplete: complete)
            }
        }
    }
    
    // adds or updates the World on the cloud
    // sets the `currentVersion` field to the local versionId
    func uploadWorld(onComplete complete: @escaping (_ : ApiResponse) -> Void) {
        // build the request
        let url = URL(string: "http://192.168.1.129:5000/api/worlds")
        var request = URLRequest(url: url!)
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.addValue("application/json", forHTTPHeaderField: "Accept")
        
        // build the data
        let worldJson = WorldJson(_id: self.data!.worldId, name: self.data!.name, currentVersion: self.data!.versionId!)
        guard let bodyData = try? ApiClient.encoder.encode(worldJson) else {
            fatalError("Cannot encode World")
        }
        
        // upload the request
        ApiClient.uploadTask(request: request, data: bodyData, complete: complete)
    }
    
    // adds or updates the WorldDoc on the cloud
    func uploadDoc(onComplete complete: @escaping (_ : ApiResponse) -> Void) {
        // build the request
        let url = URL(string: "http://192.168.1.129:5000/api/world-docs")
        var request = URLRequest(url: url!)
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.addValue("application/json", forHTTPHeaderField: "Accept")
        
        // build the data
        let worldDocJson = WorldDocJson(_id: self.data!.versionId!, lastModified: self.data!.lastModified!)
        guard let bodyData = try? ApiClient.encoder.encode(worldDocJson) else {
            fatalError("Cannot encode WorldDoc")
        }
        
        // upload the request
        ApiClient.uploadTask(request: request, data: bodyData, complete: complete)
    }
    
    func uploadMap(onComplete complete: @escaping (_ : ApiResponse) -> Void) {
        guard let versionId = self.data!.versionId else {
            fatalError("versionId not set")
        }
        
        // build the request
        let url = URL(string: "http://192.168.1.129:5000/api/world-docs/\(versionId)/world-map")
        var request = URLRequest(url: url!)
        request.httpMethod = "POST"
        request.addValue("binary/octet-stream", forHTTPHeaderField: "Content-Type")
        request.addValue("application/json", forHTTPHeaderField: "Accept")
        
        // upload the map
        ApiClient.uploadTask(request: request, data: codedData, complete: complete)
    }
}

// MARK: API Data

// https://www.raywenderlich.com/3418439-encoding-and-decoding-in-swift#toc-anchor-007

struct WorldDocJson: Codable {
    let _id: String
    let lastModified: Date
}

struct WorldJson: Codable {
    let _id: String
    let name: String
    let currentVersion: String
}
